mysql索引失效几种情况: 非左操 or 子参 和隐转

    1.非等值查询
    2.不符合最左匹配原则
    3.对索引列有操作,比如函数计算
    4.使用or
    5.子查询里需要传参
    6.隐式转换
    7.mysql估算结果是全表扫描比使用索引更快.

mysql事务隔离级别可提交读RR到底有没有解决幻读?

    1.一种是MVCC(并发版本控制,快照)情况下, 是不存在幻读的, 
    2.另一种是当前读,当前读即在一个事务执行的过程中，如果我们这个时候使用了DML语句，也就是我们平时所说的insert、update、delete语句，
        此时DML会执行当前读，它们会在操作数据库内容之前，去读取数据库中当前时间点以及提交的最新的数据，基于最新的数据的基础上，再去做这个DML语句自己的SQL逻辑。
        此时的这个读取数据库中最新已提交的数据的这个动作，就是当前读。
        当前读的情况是会发生幻读的, mysql的解决方式是使用间隙锁,锁住某个间隙,不让其插入数据.

mysql死锁

    数据库死锁,原因:并发修改同一条数据: A竞争到并修改,B和C此时抢不到,根据Innodb内部的机制改为获取共享锁(此处既是已经有了排它,怎么加的共享? 定是mysql的内部机制.),
        然后A释放, B和C此时又竞争排它锁,但是B和C此时都占有该数据的共享锁,所以排它锁加不成功.
并发修改同一条数据参考:[参考文章](https://www.modb.pro/db/55278)
![](img/img.jpg)


    事务之前对资源访问顺序的交替: 用户访问表A(上锁), 然后访问表B; 另一个用户访问表B（锁住了表B），然后企图访问表A；
    并发修改同一记录:用户A查询一条纪录，然后修改该条纪录；这时用户B修改该条纪录，这时用户A的事务里锁的性质由查询的共享锁企图上升到独占锁，而用户B里的独占锁由于A有共享锁
        存在所以必须等A释放掉共享锁，而A由于B的独占锁而无法上升的独占锁也就不可能释放共享锁，于是出现了死锁。这种死锁比较隐蔽，但在稍大点的项目中经常发生。这种解决方式是使用乐观锁
    索引不当导致的死锁:如果在事务中执行了一条不满足条件的语句，执行全表扫描，把行级锁上升为表级锁，多个这样的事务执行后，就很容易产生死锁和阻塞。类似的情况还有当表中的数据量非常庞大
        而索引建的过少或不合适的时候，使得经常发生全表扫描，最终应用系统会越来越慢，最终发生阻塞或死锁。

    解决:超时,当2个事务互相等待时,一个事务等待时间超过设置的阈值,则将其进行回滚.那么另一个事务就能执行;
        Innodb现在使用的是"等待图"的方式来进行死锁检测,在每个事务请求锁并发生等待时都会判断是否存在死锁,通常来说会选择混滚undo量最小的事务.

###缓冲池(buffer pool)

1.简介

    1.应用系统分层架构，为了加速数据访问，会把最常访问的数据，放在缓存(cache)里，避免每次都去访问数据库。
    2.操作系统，会有缓冲池(buffer pool)机制，避免每次访问磁盘，以加速数据的访问。
    3.MySQL作为一个存储系统，同样具有缓冲池(buffer pool)机制，以避免每次查询数据都进行磁盘IO。
2.InnoDB的缓冲池缓存什么？有什么用？

    1.缓存表数据与索引数据，避免每次访问都进行磁盘IO，起到加速访问的作用。
    2.可以避免磁盘IO中断,中断指当出现需要时，CPU暂时停止当前程序的执行转而执行处理新情况的程序和执行过程。 IO中断可参考https://blog.csdn.net/qq_42824842/article/details/125773763
        
[缓冲池buffer pool](https://blog.csdn.net/wuhenyouyuyouyu/article/details/93377605)


###索引
####B+树


####hash索引
实现:

    哈希索引（hash index）基于哈希表实现，只有精确匹配索引所有列的查询才有效;
    对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希码是一个较小的值。哈希码索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。
    如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储
缺点:

    1.索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行(没有覆盖索引这一说)，不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能的影响并不明显。
    2.索引数据并不是按照索引值顺序存储的，所以也就无法用于排序
    3.索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。
    4.索引只支持等值比较查询，包括=、IN()、也不支持任何范围查询。
    5.访问哈希索引的数据非常快，除非有很多哈希冲突。当出现哈希冲突的时候，存储引擎必须遍历链表中所有的行指针，逐行进行比较，直到找到所有符合条件的行。
    6.很多哈希冲突的时候,插入和删除的性能也会有影响,插入的时候要判断数据是否已经存在,删除的时候也要一个一个遍历,找到该数据的时候再删除






