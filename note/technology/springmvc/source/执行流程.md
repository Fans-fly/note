[父子容器问题](https://blog.csdn.net/qq_43842093/article/details/122008820)
1.相同类名(全限定类名)的bean在创建时会冲突,而父子容器不会冲突.

2.子容器能访问父容器,父容器不能访问子容器,controller能注入service/dao当属性, 而service/dao不能注入controller,避免不必要的错误.

3.父容器加载的属性变量只是对父容器spring本身的对象可见,如果在父容器中有properties文件，其中的属性子容器@value是访问不到的！跨容器了！

那么在springboot里,上面的问题还存在吗? 或者如果是基于注解的而非基于xml配置文件的还会有上面的问题吗?
[mvc用了父子容器而springboot没有用父子容器?](https://www.zhihu.com/question/488723652)

[springCloud中的父子容器问题](https://cloud.tencent.com/developer/article/1403379)

[从Servlet和SpringBoot整合理解父子容器](https://blog.csdn.net/daliucheng/article/details/121408902)


RequestDispatcher是个啥?

#一个请求的执行流程
![请求在springmvc的执行流程](img/511653356162_.pic.jpg)
1.DispatcherServlet中的doservice从哪儿调的?

    DispatcherServlet是前端控制器,Dispatcher有收发的意思,可以理解为前端请求的收发的地方.
    一个请求发送到javaweb,通常默认发送到servlet#service方法,DispatcherServlet也不例外,在其父类FrameworkServlet#service方法
    HttpMethod.resolve //解析http方法是否patch方法或者为空, http方法有GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS, TRACE
        是patch方法or为null则processRequest() // patch方法是对put方法的补充,是局部更新,此处不做详细跟踪,这个方法里面也是调用了doService方法
        否则super.service,即HttpServlet#service,此处根据不同的httpMethod调用不同的方法
        GET:doGet, HEAD:doHead, POST:doPost, PUT:doPut, DELETE:doDelete, OPTIONS:doOptions, TRACE:doTrace
        上面这些do**方法在FrameworkServlet有实现,下面以doGet为例进行记录
        doGet里实际调用processRequest方法
            获取LocaleContext/ServletRequestAttributes/WebAsyncManager
            registerCallableInterceptor注册一个回调拦截器RequestBindingInterceptor,是以FrameworkServlet的classname为key
            initContextHolders //初始化上下文的持有者
                LocaleContextHolder.setLocaleContext //初始化本地上下文,inheritable可继承的
                    判断是否可继承的上下文,默认false,false则将localeContext放入localeContextHolder,否则放入inheritableLocaleContextHolder
                RequestContextHolder.setRequestAttributes //设置请求属性
                    判断是否可继承的上下文,默认false,false则将localeContext放入requestAttributesHolder,否则放入inheritableRequestAttributesHolder
            doService //实际调用DispatcherServlet#doService
                向Request的attribute中放入对象:上下文对象,国际化支持解析器,主题解析器,主题
                doDispatch(request, response);//真正的进行处理转发
                    checkMultipart(request);//判断请求是不是文件上传的请求
                        multipartResolver.resolveMultipart //如果是文件上传请求,则将request转换为MultipartHttpServletRequest
                    getHandler(processedRequest) //获取一个执行器处理链HandlerExecutionChain
                        todo...
                    getHandlerAdapter //根据Handler选择我们的HandlerAdpater对象,默认是@RequestMappingHandlerAdapter对象,此处参考"2.使用controller的3种方式"
                        todo...
                    HandlerExecutionChain#applyPreHandle //调用拦截器链的applyPreHandle方法.
                        
            resetContextHolders //重置LocaleContext和RequestAttributes
            publishRequestHandledEvent //发布请求已处理事件 ServletRequestHandledEvent
                webApplicationContext.publishEvent(ServletRequestHandledEvent)
                    AbstractApplicationContext#publishEvent 
                        getApplicationEventMulticaster().multicastEvent //广播事件
                            SimpleApplicationEventMulticaster#multicastEvent
                                取出所有的ApplicationListener进行循环
                                    invokeListener -> doInvokeListener
                                        listener.onApplicationEvent//调用listener的监听方法onApplicationEvent

2.使用controller的3种方式: 不同的方式对应不同的适配器,调用也稍微有点区别
    
    1.实现Controller接口
        Simple..HandlerAdapter
    2.实现HttpRequestHandler
        HttpRequestHandlerAdapter
    3.使用@Controller标注
        RequestMappingHandlerAdapter

3.参数是怎么封装的?
    spring是可以拿到参数的,而mybatis拿不到(要通过@param注解才行,jdk1.8之后就可以拿得到了),是因为spring操作了底层的字节码
4.拦截器是怎么走的?
    拦截器preHandle()返回true是放行,返回false是不放行
5.handlermapping和handlerAdapter什么时候封装的?
    在DispatcherServlet#initStrategies中,
6.spring父子容器
7.看下鼓泡的springmvc的课程,好像更清晰一点.
8.spring整合springmvc的源码? 好像不用,因为springmvc就是利用了spring的扩展点吧?到时候可以看一看

















